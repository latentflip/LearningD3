var constants = require('constants');
var util = require('util');
var crypto = require('crypto');
var events = require('events');
var querystring = require('querystring');
var WebSocket = require('websocket').client;
var UUID = require('node-uuid');

var JSON_RPC = require('./json-rpc');
var extend = require('./utils').extend;

function has(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}

var debug = function debug() {};

function Client(config) {
  if (!(this instanceof Client)) return new Client(config);

  var self = this;

  this.secure = false;
  this.host = 'wsapi.darling.pusher.com';
  this.port = 8080;

  extend(this, config);

  // The connection associated with the client:
  // (only created on client.connect())
  this.connection = undefined;
  this.connection_id = undefined;

  Object.defineProperty(this, 'connected', {
    enumerable: true,
    configurable: true,
    get: function() {
      return self.connection && self.connection.connected === true;
    }
  });

  // Used for client related events, eg, connection state changes.
  events.EventEmitter.call(this);

  // Callback storage for RPC requests:
  this._callbacks = {};

  // Storage of instances:
  this._channels = {};
  this._sockets = {};

  this._subscriptions = [];

  // used for the firehose of events relating to all
  // channels (and excluding events that happen on sockets).
  this.channels = new events.EventEmitter();

  // used for the firehose of events relating to all
  // sockets (and excluding events that happen on channels).
  this.sockets = new events.EventEmitter();

  this.disconnecting = false;
  this.reconnection_attempts = 0;

  // validation of configuration:
  if (!this.key) {
    throw new Error('Missing "key" configuration variable.');
  }

  if (!this.secret) {
    throw new Error('Missing "secret" configuration variable.');
  }

  if (!this.app_id) {
    throw new Error('Missing "app_id" configuration variable.');
  }
}

util.inherits(Client, events.EventEmitter);

// Constants:
Client.PROTOCOL_VERSION = '0.2';
Client.AUTH_VERSION = '1.0';

// Hook to allow more easy testing.
Client.Transport = WebSocket;


exports.Client = Client;
exports.createClient = function(config) {
  return new Client(config);
};

/*-----------------------------------------------
  Hackery to enable dynamic debugging.
-----------------------------------------------*/
Object.defineProperties(Client.prototype, {
  _debug: {
    configurable: true,
    enumerable: false,
    writable: true,
    value: false
  },

  debug: {
    enumerable: true,
    configurable: true,
    set: function(newValue) {
      this._debug = !!newValue;

      if (this._debug) {
        debug = function(data) {
          console.error('WSAPI: DEBUG:', data);
        };
      } else {
        debug = function(data) {};
      }
    },
    get: function() {
      return this._debug;
    }
  }
});


/*-----------------------------------------------
  Public API:
-----------------------------------------------*/
Client.prototype.connect = function() {
  // Bail if we're already connected, this prevents
  // accidental double connection.
  if (this.connected) return;

  var self = this;
  var url = generateURL(this);

  debug('connecting to: ' + url);

  this.client = new Client.Transport();
  this.connection = null;

  this.client.on('connect', function(connection) {
    self.reconnection_attempts = 0;
    self.connection = connection;

    debug('connection opened to WSAPI.');

    connection.on('message', function(msg) {
      if (msg.type === 'utf8') {
        onIncomingMessage(self, msg.utf8Data);
      } else {
        debug('Randomly received a binary message.')
      }
    });

    connection.on('close', function(){
      self.connection = null;
      if (self.disconnecting) {
        self.emit('disconnected');
      } else {
        reconnect(self);
      }
    });

    if (self._subscriptions.length) {
      sendRequest(self, 'subscribe', {events: self._subscriptions});
    }
  });

  this.client.on('connectFailed', function(e) {
    self.connection = null;
    // NOTE: The e.message == 'socket hang up' is due to a hacky
    // work-around in node.js. There must be a better way to do this.
    if (e.errno === constants.ECONNREFUSED || e.message === 'socket hang up') {
      reconnect(self);
    } else {
      self.emit('error', e);
    }
  });

  this.client.connect(url);
};

Client.prototype.disconnect = function() {
  if (!this.connected) return;

  this.disconnecting = true;
  this.connection.close();
};

Client.prototype.subscribe = function(events, callback) {
  if (typeof events === 'string') {
    // Wrap as Array, as the API endpoint only accepts an Array of Strings.
    events = [events];
  } else if (!Array.isArray(events)) {
    throw new Error('Subscribe argument "events" must be either a String or Array');
  }

  for (var i=0, l=events.length; i<l; ++i) {
    if (this._subscriptions.indexOf(events[i]) === -1) {
      this._subscriptions.push(events[i]);
    }
  }

  if (this.connected) {
    sendRequest(this, 'subscribe', {events: events}, callback);
  }
};

Client.prototype.unsubscribe = function(events, callback) {
  if (typeof events === 'string') {
    // Wrap as Array, as the API endpoint only accepts an Array of Strings.
    events = [events];
  } else if (!Array.isArray(events)) {
    throw new Error('Unsubscribe argument "events" must be either a String or Array');
  }

  this._subscriptions = this._subscriptions.filter(function(event) {
    return events.indexOf(event) === -1;
  });

  if (this.connected) {
    sendRequest(this, 'unsubscribe', {events: events}, callback);
  }
};


Client.prototype._rpc = function(method, data, callback) {
  sendRequest(this, method, data, callback);
};


/*-----------------------------------------------
  Channel / Socket Stores:
-----------------------------------------------*/
Client.prototype.channel = function(name) {
  if (!has(this._channels, name)) {
    // TODO: swap args on Channel()
    this._channels[name] = new Channel(this, name);
  }

  return this._channels[name];
};

Client.prototype.hasChannel = function(name) {
  return has(this._channels, name);
};

Client.prototype.socket = function(id) {
  if (!has(this._sockets, id)) {
    this._sockets[id] = new Socket(this, id);
  }

  return this._sockets[id];
};

Client.prototype.hasSocket = function(id) {
  return has(this._sockets, id);
};

/*-----------------------------------------------
  A socket object allows for a nice interface
  for working with Socket's on the pusher
  network.
-----------------------------------------------*/

// TODO: swap args on Socket()
function Socket(client, id) {
  events.EventEmitter.call(this);

  this.id = id;
  this.client = client;
}

util.inherits(Socket, events.EventEmitter);

Socket.prototype.trigger = function(event, data, callback) {
  sendRequest(this.client, 'send_to_socket', {
    socket_id: this.id,
    event: event,
    data: data
  }, callback);
};


/*-----------------------------------------------
  A channel object allows a nice interface for
  interacting with channels.
-----------------------------------------------*/

// TODO: swap args on Channel()
function Channel(client, name) {
  events.EventEmitter.call(this);

  this.name = name;
  this.client = client;
}

util.inherits(Channel, events.EventEmitter);

Channel.prototype.trigger = function(event, data, socket_id, callback) {
  if (typeof socket_id === 'function') {
    callback = socket_id;
    socket_id = null;
  }

  sendRequest(this.client, 'send_to_channel', {
    channel: this.name,
    event: event,
    data: data,
    socket_id: socket_id
  }, callback);
};


/*-----------------------------------------------
  Private methods
-----------------------------------------------*/
function generateURL(client) {
  var port = client.port;
  var protocol = client.secure ? 'wss://' : 'ws://';
  var path = '/app/' + client.app_id;
  var params = querystring.stringify({
    auth_key: client.key,
    auth_timestamp: Math.floor(Date.now() / 1000),
    auth_version: Client.AUTH_VERSION,
    protocol_version: Client.PROTOCOL_VERSION
  });

  var signature = crypto.createHmac('SHA256', client.secret)
    .update('WEBSOCKET\n' + path + '\n' + params)
    .digest('hex');

  return (
    protocol +
    client.host + ':' + client.port +
    path + '?' +
    params + '&auth_signature=' + signature
  );
}

function reconnect(instance) {
  debug('reconnecting in ' + instance.reconnection_attempts + ' seconds');

  setTimeout(function() {
    var url = generateURL(instance);
    debug('reconnecting to: ' + url);

    instance.client.connect(url);
  }, 1000 * (instance.reconnection_attempts++))
}

function onIncomingMessage(client, message) {
  JSON_RPC.response.parse(message, function(err, parsed) {
    if (err !== null) {
      client.emit('error', err);
    } else {
      debug(parsed);
      if (parsed.id !== null) {
        // Replies to JSON-RPC calls MUST have an associated request ID.
        handleReply(client, parsed.id, parsed);
      } else {
        handleNotification(client, parsed);
      }
    }
  });
}

function handleReply(client, request_id, reply) {
  if (reply.error !== null) {
    var error = new Error(reply.error.message);
    error.errno = reply.error.code;

    if (has(client._callbacks, request_id)) {
      var callback = client._callbacks[request_id];

      callback(error, reply.result);

      delete client._callbacks[request_id];
    } else {
      client.emit('error', error);
    }
  } else {
    if (has(client._callbacks, request_id)) {
      var callback = client._callbacks[request_id];

      callback(null, reply.result);

      delete client._callbacks[request_id];
    }
  }
}

function handleNotification(client, notification) {
  if (notification.error === null) {
    // switch for notification types
    var type = notification.result.event;
    var payload = notification.result.data;

    if (type === 'connection_established') {
      client.connection_id = payload.socket_id;
      client.emit('connected');
    } else if (type === 'socket_opened') {
      var socket_id = payload.socket_id;
      client.sockets.emit('open', socket_id);
    } else if (type === 'socket_closed') {
      var socket_id = payload.socket_id;
      client.sockets.emit('close', socket_id);

      // clean up:
      if (has(client._sockets, socket_id)) {
        // emit close on the socket instance:
        client.socket(socket_id).emit('close');

        // remove the socket from memory space:
        delete client._sockets[socket_id];
      }
    } else if (type === 'socket_message') {
      var socket_id = payload.socket_id;
      var data = payload.data;
      var event = payload.event;

      // If the event has a channel, this means that it originated
      // on a channel object, so it's an event on a channel.
      if (has(payload, 'channel')) {
        var channel_name = payload.channel;
        // Send to the firehose of channel events:
        client.channels.emit('event', event, channel_name, socket_id, data);
        client.channels.emit('event:' + event, channel_name, socket_id, data);

        if (has(client._channels, channel_name)) {
          var channel = client.channel(channel_name);

          channel.emit('event', event, socket_id, data);
          channel.emit('event:' + event, socket_id, data);
        }
      } else {
        // Send to the firehose of all socket events:
        client.sockets.emit('event', event, socket_id, data);
        client.sockets.emit('event:' + event, socket_id, data);

        if (has(client._sockets, socket_id)) {
          var socket = client.socket(socket_id);

          socket.emit('event', event, data);
          socket.emit('event:' + event, data);
        }
      }
    } else if (type === 'warning') {
      console.error('WARNING:', payload)
    } else {
      debug('Unknown notification type: ' + type);
      debug('data: ' + JSON.stringify(notification));
    }
  } else {
    // Create an error object with the specified code, so you can
    // do things like:
    //
    //      client.on('error', function(e) {
    //        if (e.errno === 4210) {
    //          console.log('Woah, bad event name: ', e.message);
    //        }
    //      });
    //
    var error = new Error(notification.error.message);

    // set the errno on the object for easier error
    // identification.
    error.errno = notification.error.code;

    // If the user is not listening for client.on('error'), then
    // this will actually terminate the node.js process (fail-fast).
    client.emit('error', error);
  }
}

function sendRequest(client, method, params, callback) {
  if (client.connected) {
    var request, id = UUID();

    if (typeof params.data === 'undefined') {
      params.data = '';
    }

    if (typeof callback === 'function') {
      client._callbacks[id] = callback;
    }

    request = JSON_RPC.request.format(id, method, params);

    debug(request);
    client.connection.sendUTF(request);
  } else {
    if (typeof callback === 'function') {
      callback(new Error('Connection not opened'));
    } else {
      client.emit('error', new Error('Connection not opened'))
    }
  }
}
